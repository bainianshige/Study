/*
require('./01.a')

// 优先从缓存加载
// 由于 在 a 中已经加载过 b 所以这里不会重复加载
// 可以拿到其中的接口对象，不会重复加载执行里面的代码
// 目的是为了避免重复加载，提高模块加载的效率

// 判断模块标识

let fn = require('./01.b')
console.log(fn)
*/

// 模块标识符
/*
  三种情况： 
    1.核心模块 
    2.第三方模块 
    3.自己写的模块

  如果是非路径形式的模块标识

  路径形式的模块： 1- ./(当前目录，不可省略), 2- ../(上一级目录，不可省略), 3- /xxx(几乎不用)
    据对路径 d:/a/foo.js 几乎不用 
    首位的 / 在这里表示的是当前文件模块所属的磁盘跟路径
    .js 后缀名可以省略

  核心模块：本质是文件
    核心模块文件已经被编译到二进制文件中，只需要按照名字来加载就可以了

  第三方模块：
    凡是第三方模块都必须通过 npm 来下载
    使用的时候可以通过 require('包名') 的方式进行加载才可以使用
    不可能有任何一个第三方包和核心模块的名字是一样的
    既不是核心模块、也不是路径形式的模块
      先找到当前文件所在目录中的 mode_modules 目录
      node_modules/art-template/package.json 文件中的 main 属性
      main 属性就记录了 art-template 的入口模块
      然后加载使用这个第三方包， 最终加载的是文件

      如果 package.json 文件不存在或者 amin 制定的入口模块不存在
      则 node 会自动找该目录下的 index.js ，也是就是说 index.js 会作为一个默认的被选项

      如果以上所有任何一个条件都不成立，则会进入上一级的 node_modules 目录查找
      上过上一级没有，则继续往上上一级查找。。。
      如果直到当前磁盘根目录还找不到，最后报错
        can not find module xxx

注意：我们一个项目有且只有一个 node_modules,放在项目根目录中，这样的话项目中所有的子目录中的代码都可以加载到第三方包
  不会出现有多个 node_modules

模块查找机制：
  优先从缓存加载
  核心模块
  路径形式的文件模块
  第三方模块
    node_modules/art-template/package.json
*/



let template = require('art-template')

require('模块标识符')
